#问题
在实际开发过程中，往往会需要生成大量重复的对象，当对象使用结束后则会成为不再需要的垃圾进行销毁。而直接进行对象的生成与销毁已经增加内存的消耗，而对象的销毁常常会伴有内存泄露的问题存才，当内存泄露产生的垃圾无法被回收时就会开始占用更多的内存，长此以往最终会导致程序崩溃。


#对象池介绍
我们知道，一个对象的生命周期包括：创建、使用、销毁。我们发现，真正我们关注的是对象的使用，而创建和销毁是为了使用对象而产生的额外开销，通常来讲，这个开销很小，可以忽略不计。但是如果一个程序中涉及到很多的对象创建，并且创建时间比较长，那我们就会很明显的感觉到这部分所造成的系统速度受限。到了这里，大家都会理解了池化的意义，就是对象使用完不销毁，而是存放起来，等着系统再次需要的时候直接拿出来。其思想就是这样：创建一次，使用多次，以空间换取时间。到此我们看到了对象池的有点，但是对象池是万能的吗？它适合任何场景的使用吗？其实不然，当对象仅仅只在某段时间会生成且不是大量生成时，任然使用它导致大量对象存在池中不进行销毁反而会占用空间降低性能。


#对象池实现
对象池的思想在于创建一个集合当作对象池存储需要重复创建的，当对象创建时首先检查对象池中是否存在该类对象，如果存在则直接引用，如果不存在才进行创建。而当销毁对象时则选择将对象隐藏并存入到对象池中。当程序再次请求需要生成一个对象时，对象池将该对象移出，发送给请求者。这样的设计方式大大的减少了对象的使用将不需要的对象重复利用。
对象池的实现首先会选择将其作为一个单例进行使用，单例的设计思想为，在整个程序中该类只有一个对象，而该类可以被所有对象使用。这样的设计也符合对象池唯一的思想。首先编写一个单例时需要在该类中定义一个静态变量，而该静态变量就是该类本身。而该类的实例则通过一个静态方法创建，该方法只创建一个对象并赋值给静态变量，之后再有其他类调用它创建时直接返回静态变量即可，最后将构造方法设为私有化，使外部无法直接实例化该对象，由此做到了对象的唯一性。
（单例扯皮到此结束）
现在开始考虑如何将对象存入对象池了，多列对象的存取C#中通常会使用dictionary，以键值对的形式存储。键常使用相同对象的且不与其他组对象冲突的键。而值则为一个List集合，用于存储一组对象。

获取对象
当获取对象时分为两种情况进行分析，第一种为对象池中没有对象，此时则真正的去进行实例化对象并返回，第二种则是对象池中已存在该索引，并且对应的List集合中有对象，则将集合中的对象返回，将集合中该对象剔除。


存储对象
将需要存入对象池的对象销毁时改为不引用，且将其传到对象池存储方法内，存储方法获取对象名，查找对象池是否含有该对象的键值，有就直接存入对应List集合，没有就新建一组键值对存储该对象名以及该对象集合，将对象存入。